/**
 * ‚ùå Please do not edit this file.
 */

import express from "express";
import ViteExpress from "vite-express";
import http from "http";
import { WebSocketServer, WebSocket, MessageEvent } from "ws";
import {
  Instrument,
  InstrumentSymbol,
  WebSocketClientMessageJson,
  WebSocketServerMessageJson,
} from "../common-leave-me";

const instrumentInfoMap: Record<
  InstrumentSymbol,
  Omit<Instrument, "lastQuote">
> = {
  BTC: {
    name: "Bitcoin",
    category: "crypto",
    code: "BTC",
    pair: ["BTC", "USD"],
  },
  SP500: {
    name: "S&P 500",
    category: "indicies",
    code: "SP500",
    pair: ["SP500", "USD"],
  },
  ETH: {
    name: "Ethereum",
    category: "crypto",
    code: "ETH",
    pair: ["ETH", "USD"],
  },
  US100: {
    name: "US 100",
    category: "indicies",
    code: "US100",
    pair: ["US100", "USD"],
  },
  TSLA: {
    name: "Tesla",
    category: "stocks",
    code: "TSLA",
    pair: ["TSLA", "USD"],
  },
  AAPL: {
    name: "Apple Inc",
    category: "stocks",
    code: "AAPL",
    pair: ["AAPL", "USD"],
  },
  EURUSD: {
    name: "EUR/USD",
    category: "forex",
    code: "EURUSD",
    pair: ["EUR", "USD"],
  },
};

const instrumentMockPriceRanges: Record<
  InstrumentSymbol,
  [number, number, number]
> = {
  BTC: [27330, 27355, 2],
  SP500: [4132, 4133, 2],
  ETH: [1843, 1856, 2],
  US100: [12984, 12985, 2],
  TSLA: [164, 167, 2],
  AAPL: [168, 169, 2],
  EURUSD: [1.07, 1.09, 3],
};

function genRandInstrumentQuote(instrumentCode: InstrumentSymbol) {
  const [min, max, decimalPlaces] = instrumentMockPriceRanges[instrumentCode];
  const rand =
    Math.random() < 0.5
      ? (1 - Math.random()) * (max - min) + min
      : Math.random() * (max - min) + min;
  const power = Math.pow(10, decimalPlaces);
  return Math.floor(rand * power) / power;
}

class InstrumentSocketConnection {
  private _ws: WebSocket;
  private _instrumentSubscriptions = new Set<InstrumentSymbol>();
  private _interval: NodeJS.Timer | undefined;

  constructor(ws: WebSocket) {
    this._ws = ws;
    this._ws.addEventListener("message", this.onMessage.bind(this));
    this._ws.addEventListener("close", this.onClose.bind(this));
    this.emitUpdates();
  }

  emitUpdates() {
    this._interval = setInterval(() => {
      const instruments: Instrument[] = Array.from(
        this._instrumentSubscriptions
      ).map((code) => {
        const instrumentInfo = instrumentInfoMap[code];
        const lastQuote = genRandInstrumentQuote(code);
        if (instrumentInfo.category === "forex") {
          return {
            ...instrumentInfo,
            lastQuote,
            pair: [instrumentInfo.pair[1], instrumentInfo.pair[0]],
          };
        }

        return {
          ...(instrumentInfoMap[code] as Instrument),
          lastQuote: genRandInstrumentQuote(code),
        };
      });

      if (!instruments.length) {
        return;
      }

      const json: WebSocketServerMessageJson = {
        type: "update",
        instruments,
      };

      this._ws.send(JSON.stringify(json));
    }, 2000);
  }

  onMessage(message: MessageEvent) {
    try {
      const data = JSON.parse(
        message.data.toString()
      ) as WebSocketClientMessageJson;

      console.log("received: %s", data);

      switch (data.type) {
        case "subscribe":
          data.instrumentSymbols.forEach((t) =>
            this._instrumentSubscriptions.add(t)
          );
          break;
        case "unsubscribe":
          data.instrumentSymbols.forEach((t) =>
            this._instrumentSubscriptions.delete(t)
          );
          break;
      }
    } catch (e) {
      console.error("Cannot parse client message", e);
    }
  }

  onClose() {
    clearInterval(this._interval);
    this._instrumentSubscriptions.clear();
    this._ws.removeAllListeners();
  }
}

class InstrumentSocketServer {
  private _wss: WebSocketServer;
  private _connections = new Set<InstrumentSocketConnection>();

  constructor() {
    this._wss = new WebSocketServer({ server, path: "/ws" });
    this._wss.on("connection", this.onConnection.bind(this));
  }

  onConnection(ws: WebSocket) {
    const connection = new InstrumentSocketConnection(ws);
    this._connections.add(connection);

    ws.onclose = () => {
      this._connections.delete(connection);
    };
  }
}

const app = express();
const server = http.createServer(app).listen(3000);

new InstrumentSocketServer();

// Run
ViteExpress.bind(app, server);
